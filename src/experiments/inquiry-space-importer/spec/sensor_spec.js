// Generated by CoffeeScript 1.3.3
(function() {

  describe("SensorApplet class", function() {
    var applet;
    applet = null;
    beforeEach(function() {
      return applet = new ISImporter.SensorApplet();
    });
    it("should exist", function() {
      return expect(applet).toBeDefined();
    });
    describe("testAppletReady method", function() {
      return it("should defer to child class implementation", function() {
        return expect(applet.testAppletReady).toThrow();
      });
    });
    describe("_appendHTML method", function() {
      return it("should exist and be callable", function() {
        return expect(typeof applet._appendHTML).toBe('function');
      });
    });
    describe("getHTML method", function() {
      return it("should defer to child class implementation", function() {
        return expect(applet.getHTML).toThrow();
      });
    });
    describe("getState method", function() {
      return describe("initially", function() {
        return it("should return 'not appended'", function() {
          return expect(applet.getState()).toBe('not appended');
        });
      });
    });
    describe("append method", function() {
      beforeEach(function() {
        spyOn(applet, 'getHTML').andReturn('<applet> tag from getHTML method');
        spyOn(applet, '_appendHTML');
        return applet.testAppletReady = function() {};
      });
      it("should call the getHTML method to request the applet HTML", function() {
        applet.append();
        return expect(applet.getHTML).toHaveBeenCalled();
      });
      it("should append the applet HTML to the DOM", function() {
        applet.append();
        return expect(applet._appendHTML).toHaveBeenCalledWith('<applet> tag from getHTML method');
      });
      it("should go into 'appended' state", function() {
        applet.append();
        return expect(applet.getState()).toBe('appended');
      });
      describe("when the applet is in the 'not appended' state", function() {
        beforeEach(function() {
          return applet.getState = function() {
            return 'not appended';
          };
        });
        return it("should not throw an error", function() {
          return expect(function() {
            return applet.append();
          }).not.toThrow();
        });
      });
      return describe("when the applet is not in the 'not appended' state", function() {
        beforeEach(function() {
          return applet.getState = function() {
            return 'appended';
          };
        });
        return it("should throw an error", function() {
          return expect(function() {
            return applet.append();
          }).toThrow();
        });
      });
    });
    describe("after appending", function() {
      beforeEach(function() {
        applet.getHTML = function() {
          return 'dummy <applet>';
        };
        applet._appendHTML = function() {};
        applet.testAppletReady = function() {};
        return applet.testAppletReadyInterval = 50;
      });
      it("should call the testAppletReady method in a timeout", function() {
        spyOn(applet, 'testAppletReady');
        runs(function() {
          applet.append();
          return expect(applet.testAppletReady).not.toHaveBeenCalled();
        });
        waits(100);
        return runs(function() {
          return expect(applet.testAppletReady).toHaveBeenCalled();
        });
      });
      return describe("when testAppletReady returns false", function() {
        beforeEach(function() {
          return spyOn(applet, 'testAppletReady').andReturn(false);
        });
        it("should continue calling testAppletReady", function() {
          runs(function() {
            return applet.append();
          });
          waits(200);
          return runs(function() {
            return expect(applet.testAppletReady.callCount).toBeGreaterThan(1);
          });
        });
        return describe("when testAppletReady subsequently returns true", function() {
          it("should stop calling testAppletReady", function() {
            runs(function() {
              return applet.append();
            });
            waits(100);
            runs(function() {
              expect(applet.testAppletReady).toHaveBeenCalled();
              applet.testAppletReady.reset();
              return applet.testAppletReady.andReturn(true);
            });
            waits(100);
            runs(function() {
              expect(applet.testAppletReady).toHaveBeenCalled();
              return applet.testAppletReady.reset();
            });
            waits(100);
            return runs(function() {
              return expect(applet.testAppletReady).not.toHaveBeenCalled();
            });
          });
          return it("should transition to the 'applet ready' state and fire the 'appletReady' event", function() {
            var appletReady;
            appletReady = jasmine.createSpy('appletReady');
            applet.on('appletReady', appletReady);
            runs(function() {
              return applet.append();
            });
            waits(100);
            runs(function() {
              expect(applet.getState()).toBe('appended');
              expect(appletReady).not.toHaveBeenCalled();
              return applet.testAppletReady.andReturn(true);
            });
            waits(100);
            return runs(function() {
              expect(applet.getState()).toBe('applet ready');
              return expect(appletReady).toHaveBeenCalled();
            });
          });
        });
      });
    });
    describe("the sensorIsReady method", function() {
      beforeEach(function() {
        return applet._state = 'applet ready';
      });
      it("should go to the 'stopped' state", function() {
        expect(applet.getState()).toBe('applet ready');
        applet.sensorIsReady();
        return expect(applet.getState()).toBe('stopped');
      });
      it("should fire the 'sensorReady' event", function() {
        var sensorReady;
        sensorReady = jasmine.createSpy('sensorReady');
        applet.on('sensorReady', sensorReady);
        applet.sensorIsReady();
        return expect(sensorReady).toHaveBeenCalled();
      });
      describe("the 'start' method", function() {
        beforeEach(function() {
          return spyOn(applet, '_startSensor');
        });
        describe("in the 'stopped' state", function() {
          beforeEach(function() {
            applet._state = 'stopped';
            return applet.start();
          });
          it("should call the _startSensor method", function() {
            return expect(applet._startSensor).toHaveBeenCalled();
          });
          return it("should call go to the 'started' state", function() {
            return expect(applet.getState()).toBe('started');
          });
        });
        return describe("not in the 'stopped' state", function() {
          beforeEach(function() {
            applet._state = 'not stopped';
            return applet.start();
          });
          it("should not call the _startSensor method", function() {
            return expect(applet._startSensor).not.toHaveBeenCalled();
          });
          return it("should not change state", function() {
            return expect(applet.getState()).toBe('not stopped');
          });
        });
      });
      return describe("the 'stop' method", function() {
        beforeEach(function() {
          return spyOn(applet, '_stopSensor');
        });
        describe("in the 'started' state", function() {
          beforeEach(function() {
            applet._state = 'started';
            return applet.stop();
          });
          it("should call the _stopSensor method", function() {
            return expect(applet._stopSensor).toHaveBeenCalled();
          });
          return it("should go the the 'stopped' state", function() {
            return expect(applet.getState()).toBe('stopped');
          });
        });
        return describe("not in the 'started' state", function() {
          beforeEach(function() {
            applet._state = 'not started';
            return applet.stop();
          });
          it("should not call the _stopSensor method", function() {
            return expect(applet._stopSensor).not.toHaveBeenCalled();
          });
          return it("should not change state", function() {
            return expect(applet.getState()).toBe('not started');
          });
        });
      });
    });
    return describe("initially", function() {
      describe("inAppletCallback method", function() {
        return it("should return false");
      });
      describe("after endAppletCallback is called", function() {
        return it("should throw an error");
      });
      return describe("after startAppletCallback method is called", function() {
        describe("inAppletCallback method", function() {
          return it("should return true");
        });
        describe("after startAppletCallback method is called again", function() {
          return it("should throw an error");
        });
        return describe("after endAppletCallback method is called", function() {
          return describe("inAppletCallack method", function() {
            return it("should return false");
          });
        });
      });
    });
  });

  describe("GoIOApplet class", function() {
    it("should exist");
    it("should be a subclass of SensorsApplet");
    describe("getHTML method", function() {
      return it("should construct an appropriate applet tag");
    });
    describe("testAppletReady method", function() {
      it("should call initSensorInterface method of the applet instance");
      it("should send the 'listenerPath' property to initSensorInterface");
      describe("if initSensorInterface throws an error", function() {
        return it("should return false");
      });
      return describe("if initSensorInterface does not throw an error", function() {
        return it("should return true");
      });
    });
    describe("sensorsReadyWhenAppletReady property", function() {
      return it("should be false");
    });
    describe("sensorsReady method", function() {
      it("should call startAppletCallback");
      it("should call sensorIsReady method while inAppletCallback is true");
      return it("should call endAppletCallback");
    });
    describe("The dataReceived method", function() {
      it("should call startAppletCallback");
      it("should call newData callback while inAppletCallback is true");
      return it("should call endAppletCallback");
    });
    describe("_stopSensor method", function() {
      describe("if inAppletCallback is true", function() {
        it("should set a timer");
        return describe("when the timer expires", function() {
          return it("should call the _stopSensor method again");
        });
      });
      return describe("if inAppletCallack is false", function() {
        return it("should call the applet method stopCollecting");
      });
    });
    return describe("_startSensor method", function() {
      describe("if inAppletCallback is true", function() {
        it("should set a timer");
        return describe("when the timer expires", function() {
          return it("should call the _startSensor method again");
        });
      });
      return describe("if inAppletCallack is false", function() {
        return it("should call the applet method startCollecting");
      });
    });
  });

  /*
  
  responsibilities of SensorApplet
  
    # SHOULD THERE BE a division of responsibility between SensorApplet and GoIOApplet?
  
    appends applet tag to DOM
    waits for applet startup
    records start and end of applet callback (should never call applet method within applet callback, apparently)
    removes applet tag from DOM when requested
  reacords lifecycle of applet (not appended, appended, applet ready, sensors ready, removed)
  
  responsibilities of GoIOApplet
    constructs appropriate applet tag
  
  
  
    forwards sensor ready event to callback
    forwards data received events to callback
    forwards metadata events to callback (if ever implemented)
  */


}).call(this);
